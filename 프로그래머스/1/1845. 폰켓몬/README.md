# [level 1] 폰켓몬 - 1845 

<details>
<summary><h3>1. 문제</h3></summary>
<div markdown="1">
        
[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/1845) 
### 성능 요약

메모리: 36.5 MB, 시간: 2.09 ms

### 구분

코딩테스트 연습 > 해시

### 채점결과

정확성: 100.0<br/>합계: 100.0 / 100.0

### 제출 일자

2025년 03월 07일 13:14:50

### 문제 설명

<p>당신은 폰켓몬을 잡기 위한 오랜 여행 끝에, 홍 박사님의 연구실에 도착했습니다. 홍 박사님은 당신에게 자신의 연구실에 있는 총 N 마리의 폰켓몬 중에서 N/2마리를 가져가도 좋다고 했습니다.<br>
홍 박사님 연구실의 폰켓몬은 종류에 따라 번호를 붙여 구분합니다. 따라서 같은 종류의 폰켓몬은 같은 번호를 가지고 있습니다. 예를 들어 연구실에 총 4마리의 폰켓몬이 있고, 각 폰켓몬의 종류 번호가 [3번, 1번, 2번, 3번]이라면 이는 3번 폰켓몬 두 마리, 1번 폰켓몬 한 마리, 2번 폰켓몬 한 마리가 있음을 나타냅니다. 이때, 4마리의 폰켓몬 중 2마리를 고르는 방법은 다음과 같이 6가지가 있습니다.</p>

<ol>
<li>첫 번째(3번), 두 번째(1번) 폰켓몬을 선택</li>
<li>첫 번째(3번), 세 번째(2번) 폰켓몬을 선택</li>
<li>첫 번째(3번), 네 번째(3번) 폰켓몬을 선택</li>
<li>두 번째(1번), 세 번째(2번) 폰켓몬을 선택</li>
<li>두 번째(1번), 네 번째(3번) 폰켓몬을 선택</li>
<li>세 번째(2번), 네 번째(3번) 폰켓몬을 선택</li>
</ol>

<p>이때, 첫 번째(3번) 폰켓몬과 네 번째(3번) 폰켓몬을 선택하는 방법은 한 종류(3번 폰켓몬 두 마리)의 폰켓몬만 가질 수 있지만, 다른 방법들은 모두 두 종류의 폰켓몬을 가질 수 있습니다. 따라서 위 예시에서 가질 수 있는 폰켓몬 종류 수의 최댓값은 2가 됩니다.<br>
당신은 최대한 다양한 종류의 폰켓몬을 가지길 원하기 때문에, 최대한 많은 종류의 폰켓몬을 포함해서 N/2마리를 선택하려 합니다. N마리 폰켓몬의 종류 번호가 담긴 배열 nums가 매개변수로 주어질 때, N/2마리의 폰켓몬을 선택하는 방법 중, 가장 많은 종류의 폰켓몬을 선택하는 방법을 찾아, 그때의 폰켓몬 종류 번호의 개수를 return 하도록 solution 함수를 완성해주세요.</p>

<h5>제한사항</h5>

<ul>
<li>nums는 폰켓몬의 종류 번호가 담긴 1차원 배열입니다.</li>
<li>nums의 길이(N)는 1 이상 10,000 이하의 자연수이며, 항상 짝수로 주어집니다.</li>
<li>폰켓몬의 종류 번호는 1 이상 200,000 이하의 자연수로 나타냅니다.</li>
<li>가장 많은 종류의 폰켓몬을 선택하는 방법이 여러 가지인 경우에도, 선택할 수 있는 폰켓몬 종류 개수의 최댓값 하나만 return 하면 됩니다.</li>
</ul>

<hr>

<h5>입출력 예</h5>
<table class="table">
        <thead><tr>
<th>nums</th>
<th>result</th>
</tr>
</thead>
        <tbody><tr>
<td>[3,1,2,3]</td>
<td>2</td>
</tr>
<tr>
<td>[3,3,3,2,2,4]</td>
<td>3</td>
</tr>
<tr>
<td>[3,3,3,2,2,2]</td>
<td>2</td>
</tr>
</tbody>
      </table>
<h5>입출력 예 설명</h5>

<p>입출력 예 #1<br>
문제의 예시와 같습니다.</p>

<p>입출력 예 #2<br>
6마리의 폰켓몬이 있으므로, 3마리의 폰켓몬을 골라야 합니다.<br>
가장 많은 종류의 폰켓몬을 고르기 위해서는 3번 폰켓몬 한 마리, 2번 폰켓몬 한 마리, 4번 폰켓몬 한 마리를 고르면 되며, 따라서 3을 return 합니다.</p>

<p>입출력 예 #3<br>
6마리의 폰켓몬이 있으므로, 3마리의 폰켓몬을 골라야 합니다.<br>
가장 많은 종류의 폰켓몬을 고르기 위해서는 3번 폰켓몬 한 마리와 2번 폰켓몬 두 마리를 고르거나, 혹은 3번 폰켓몬 두 마리와 2번 폰켓몬 한 마리를 고르면 됩니다. 따라서 최대 고를 수 있는 폰켓몬 종류의 수는 2입니다.</p>


> 출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges

</div>
</details>

----

### 2. 오늘의 개념정리
#### Map
- key - value 형식의 자료구조
- key 삽입 순서를 기억함
- key 에는 중복 값이 들어갈 수 없지만 value에는 중복 값이 들어갈 수 있다.
- 뛰어난 검색 속도를 가지고 있다
- 인덱스가 따로 X → **`iterator`** 사용해야함
- 주요 메서드

```jsx
// key를 이용해 value를 저장
map.set(key, value)
// key에 해당하는 값 반환, key가 존재X -> undefined 반환
map.get(key)
// key 가 존재하면 true, 아니면 false
map.has(key)
// key에 해당하는 값 삭제
map.delete(key)
// map 안의 모든 요소 제거
map.clear()
// 요소 개수 반환
map.size

// 각 요소의 키 iterator 객체 반환
map.keys()
// 각 요소의 값 iterator 객체 반환
map.values()
// 요소의 key, value 쌍으로 하는 iterable 객체 반환
map.entries()
```

#### Set
- 중복 존재 X
- 모든 값들은 고유하며 새로운 값을 추가하거나 변경하면 값 비교가 이루어짐
- 인덱스 사용 X
- 삽입 순서대로 요소 순회
- `NaN` 과 `undefined` 도 set에 저장할 수 있다
- 인덱스가 따로 X → **`iterator`** 사용해야함  

---
### 3. 더 좋은 풀이
```jsx
function solution(nums) {
    const max = nums.length / 2;
    const arr = [...new Set(nums)];
    
    return arr.length > max ? max : arr.length;
}
```
⇒ 종류의 개수가 필요하기 때문에 중복이 존재할 수 없는 set을  사용

